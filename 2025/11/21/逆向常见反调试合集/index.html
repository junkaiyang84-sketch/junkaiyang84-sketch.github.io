<!-- build time:Sat Nov 22 2025 14:18:45 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习及生活笔记"><link rel="canonical" href="http://example.com/2025/11/21/%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E5%8F%8D%E8%B0%83%E8%AF%95%E5%90%88%E9%9B%86/"><title>逆向常见反调试合集 - 分享 | Yume Shoka = Hexo</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">逆向常见反调试合集</h1><div class="meta"><span class="item" title="创建时间：2025-11-21 21:23:01"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-11-21T21:23:01+08:00">2025-11-21</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://t.alcy.cc/fj?79793"></li><li class="item" data-background-image="https://t.alcy.cc/fj?159649"></li><li class="item" data-background-image="https://t.alcy.cc/fj?798461"></li><li class="item" data-background-image="https://t.alcy.cc/fj?495322"></li><li class="item" data-background-image="https://t.alcy.cc/fj?398592"></li><li class="item" data-background-image="https://t.alcy.cc/fj?655138"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%88%86%E4%BA%AB/" itemprop="item" rel="index" title="分类于 分享"><span itemprop="name">分享</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2025/11/21/%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E5%8F%8D%E8%B0%83%E8%AF%95%E5%90%88%E9%9B%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Pretend"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><div class="body md" itemprop="articleBody"><h1 id="逆向常见反调试合集"><a class="anchor" href="#逆向常见反调试合集">#</a> 逆向常见反调试合集</h1><h2 id="1-反调试简介"><a class="anchor" href="#1-反调试简介">#</a> 1、反调试简介</h2><p>反调试是一种用于阻碍程序动态调试的技术，这里大致说明一下反调试的工作原理：<br>在操作系统内部提供了一些 API (<strong>即应用程序编程接口，可以允许两个完全不同的应用程序相互 “交谈” 并交换数据，而不需要知道彼此内部是如何工作的</strong>)，用于调试器调试。当调试器调用这些 API 时系统就会在被调试的进程内存中留下与调试器相关的信息。一部分信息是可以被抹除的，也有一部分信息是难以抹除的。<br>当调试器附加到目标程序后，用户的很多行为将优先被调试器捕捉和处理。其中大部分是通过异常捕获通信的，包括断点的本质就是异常。如果调试器遇到不想处理的信息，一种方式是忽略，另一种方式是交给操作系统处理。</p><p>到目前为止，程序有两种方式检测自己是否被调试：</p><pre><code>(1)检测内存中是否有调试器的信息。
(2)通过特定的指令或触发特定异常，检测返回结果。  
</code></pre><p>通常来说，存在反调试的程序，当检测到自身处于调试状态时，就会控制程序绕过关键代码，防止关键代码被调试，或者干脆直接退出程序。</p><h2 id="2-反调试的类型"><a class="anchor" href="#2-反调试的类型">#</a> 2、反调试的类型</h2><h2 id="1api反调试"><a class="anchor" href="#1api反调试">#</a> （1）API 反调试</h2><p>Windows 内部提供了一些用于检测调试器的 API。<br>其中一个 API 是 <strong>IsDebuggerPresent</strong>，原型为：<br></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsDebuggerPresent</span>()</span>;</span><br></pre></td></tr></table></figure><br>返回值为 1 表示当前进程被调试的状态，反之为 0。<br>另一个常用 API 是<strong> CheckRemoteDebuggerPresent</strong>，原型为：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="built_in">CheckRemoteDebuggerPresent</span>(HANDLE hProcess, PBOOL pbDebuggerPresent);</span><br></pre></td></tr></table></figure><br>返回值为 1 表示当前进程被调试的状态，反之为 0.<p></p><h2 id="2peb反调试"><a class="anchor" href="#2peb反调试">#</a> （2）PEB 反调试</h2><p>当程序处于 3 环 (低权限) 时， FS:[0] 寄存器指向 TEB (Thread Environment Block)，即线程环境块结构体，TEB 向后偏移 0x30 字节的位置保存的是 PEB (Process Environment Block ), 即进程环境块的结构体地址。PEB 中的部分成员是与调息相关的成员，当调试器通过 Windows 提供的 API 调试目标程序时，Windows 会将一部分调试信息写人这个结构体中。<br></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;dt_TEB</span><br><span class="line">nt! _TEB</span><br><span class="line">	<span class="params">...</span></span><br><span class="line">	+<span class="number">0x030</span> ProcessEnvironmentBlock :Ptr32_PEB</span><br><span class="line">	<span class="params">...</span></span><br><span class="line">kd&gt;dt_TEB</span><br><span class="line">	<span class="params">...</span></span><br><span class="line">	+<span class="number">0x002</span> BeingDebugged	:UChar	</span><br><span class="line">	<span class="params">...</span></span><br><span class="line">	+Ox018 ProcessHeap	:Ptr32 <span class="literal">Void</span>	</span><br><span class="line">	<span class="params">...</span></span><br><span class="line">	+<span class="number">0x068</span> NtGlobalF1ag	:Uint4B</span><br><span class="line">    <span class="params">...</span></span><br></pre></td></tr></table></figure><br>如<strong> NtGlobalFlag</strong><p></p><p>在 32 位机器上，<strong>NtGlobalFlag</strong> 字段位于<strong> PEB</strong> (进程环境块)<strong>0x68</strong> 的偏移处，64 位机器则是在偏移<strong> 0xBC</strong> 位置。该字段的默认值为 0. 当调试器正在运行时，该字段会被设置为一个特定的值。尽管该值并不能十分可信地表明某个调试器真的有在运行，但该字段常出于该目的而被使用.<br></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">fs</span>:[<span class="number">30h</span>] → [<span class="built_in">eax</span>+<span class="number">2</span>] (BeingDebugged)；[<span class="built_in">eax</span>+<span class="number">68h</span>] (NtGlobalFlag)</span><br></pre></td></tr></table></figure><br>该字段包含有一系列的标志位。由调试器创建的进程会设置以下标志位:<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">FLG_HEAP_ENABLE_TAIL_CHECK</span> (<span class="number">0</span>x10)</span><br><span class="line"><span class="attribute">FLG_HEAP_ENABLE_FREE_CHECK</span> (<span class="number">0</span>x20)</span><br><span class="line"><span class="attribute">FLG_HEAP_VALIDATE_PARAMETERS</span> (<span class="number">0</span>x40)</span><br></pre></td></tr></table></figure><br>因此，可以检查这几个标志位来检测调试器是否存在。比如用形如以下的 32 位的代码在 32 位机器上进行检测:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">fs</span>:[<span class="number">30h</span>] <span class="comment">;Process Environment Block</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">eax</span>+<span class="number">68h</span>] <span class="comment">;NtGlobalFlag</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">70h</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>, <span class="number">70h</span></span><br><span class="line"><span class="keyword">je</span> being_debugged</span><br></pre></td></tr></table></figure><br>以下是 64 位的代码在 64 位机器上的检测代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="number">60h</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">rsi</span></span><br><span class="line"><span class="symbol">gs:</span><span class="keyword">lodsq</span>                <span class="comment">;Process Environment Block</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">rsi</span>*<span class="number">2</span>+<span class="built_in">rax</span>-<span class="number">14h</span>] <span class="comment">;NtGlobalFlag</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">70h</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>, <span class="number">70h</span></span><br><span class="line"><span class="keyword">je</span> being_debugged</span><br></pre></td></tr></table></figure><br>要注意的是，如果是一个 32 位程序在 64 位机器上运行，那么实际上会存在两个 PEB: 一个是 32 位部分的而另一个是 64 位. 64 位的 PEB 的对应字段也会像在 32 位的那样而改变.<br>于是我们就还有以下的，用 32 位的代码检测 64 位机器环境:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">fs</span>:[<span class="number">30h</span>] <span class="comment">; Process Environment Block</span></span><br><span class="line"><span class="comment">;64-bit Process Environment Block</span></span><br><span class="line"><span class="comment">;follows 32-bit Process Environment Block</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">eax</span>+<span class="number">10bch</span>] <span class="comment">;NtGlobalFlag</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">70h</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>, <span class="number">70h</span></span><br><span class="line"><span class="keyword">je</span> being_debugged</span><br></pre></td></tr></table></figure><br>有以下 2 种方法来绕过 NtGlobalFlag 的检测：<p></p><pre><code>    手动修改标志位的值 (FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK, FLG_HEAP_VALIDATE_PARAMETERS)；  
    在 Windbg 禁用调试堆的方式启动程序 (windbg -hd program.exe)  
</code></pre><p>在 PEB 结构体中，<strong>BeingDebugged、ProcessHeap、NtGlobalFlag</strong> 是与调试信息相关的三个重要成员。</p><pre><code>BeingDebugged:当进程处于被调试状态时，值为1，否则为0。
ProcessHeap:指向Heap结构体，偏移0xC处为Flags成员，偏移0x10处为ForceFlags成员。通常情况下，Flags的值为2.ForceFlags的值为0，当进程被调试时会发生改变。  
NGlobalFlag:占四个字节，默认值为0。当进程处于被调试状态时，第一个字节会被置为0x70。  
</code></pre><p>通过 FS.Base 能够定位到 TEB，再通过 TEB+0x30 能够定位 PEB。通过在内存中检测或修改相关成员的值，便可达到反试、反反调试的效果。（<strong>如 fs:[30h] 指令的作用就是从 TEB 中拿到了 PEB 的钥匙，然后进去看了看 BeingDebugged 是 0 还是 1</strong>）</p><h2 id="3tls反调试"><a class="anchor" href="#3tls反调试">#</a> （3）TLS 反调试</h2><p>TLS (Thread Local Storage)，即线程局部存储是 Windows 提供的一种处理机制，每进行一次线程切换，便会调用一次 TLS 回调。它本意是想给每个线程都提供访问全局变量的机会。例如，需要统计当前程序进行了多少次线程切换，但并不想让其他线程访问到这个计数变量，使用 TLS 进行计数，便能够解决这个问题，一个程序能设置多个 TLS.</p><p>由于进程在启动时至少需要创建一个线程来运行，因此在调用 main 函数前就会调用一次 TLS 回调。利用这个特点，在 TLS 回调中写入与反调试相关的代码，便可悄无声息地令调试器失效。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS回调函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">TLS_Callback</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Reason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        <span class="comment">// 检测是否存在调试器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsDebuggerPresent</span>()) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Debugger detected!\n&quot;</span>;</span><br><span class="line">            <span class="built_in">ExitProcess</span>(<span class="number">1</span>);  <span class="comment">// 如果检测到调试器则退出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;No debugger detected.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明TLS回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg(<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line">EXTERN_C <span class="type">const</span> PIMAGE_TLS_CALLBACK pTLS_CALLBACK = TLS_Callback;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__attribute__((<span class="built_in">section</span>(<span class="string">&quot;.CRT$XLB&quot;</span>))) PIMAGE_TLS_CALLBACK pTLS_CALLBACK = TLS_Callback;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Program started.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>TLS_Callback</strong>：TLS 的回调函数，每当一个新线程创建时，或者进程加载时，它都会被调用。<br><strong>IsDebuggerPresent</strong>：这是 Windows 提供的 API，用来检查当前进程是否被调试。<br>#<strong>pragma const_seg</strong>：用于指定 TLS 回调函数的位置，它被放在.<strong>CRT$XLB</strong> 节中，这样 Windows 在加载时会自动执行。<p></p><h2 id="4进程名反调试"><a class="anchor" href="#4进程名反调试">#</a> （4）进程名反调试</h2><p>当使用调试器调试程序时，调试器是一个独立的进程，运行在内存中。若在程序执行到某一反调试方法。阶段时遍历当前系统中的进程列表，检测是否存在与调试器相关的进程名，也是一种可行的方法。<br>示例如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否存在指定的调试器进程</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsDebuggerProcessRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* debuggerNames[] = &#123; <span class="string">&quot;ollydbg.exe&quot;</span>, <span class="string">&quot;x64dbg.exe&quot;</span>, <span class="string">&quot;ida.exe&quot;</span>, <span class="string">&quot;windbg.exe&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程快照</span></span><br><span class="line">    HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROCESSENTRY32 pe32;</span><br><span class="line">    pe<span class="number">32.</span>dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历进程列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(hSnapshot, &amp;pe32)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历已知的调试器名称</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; debuggerName : debuggerNames) &#123;</span><br><span class="line">                <span class="comment">// 将进程名转换为小写以进行匹配</span></span><br><span class="line">                std::string processName = pe<span class="number">32.</span>szExeFile;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : processName) c = <span class="built_in">tolower</span>(c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (processName == debuggerName) &#123;</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到匹配的调试器进程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapshot, &amp;pe32));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 未找到调试器进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsDebuggerProcessRunning</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Debugger process detected! Exiting...\n&quot;</span>;</span><br><span class="line">        <span class="built_in">ExitProcess</span>(<span class="number">1</span>);  <span class="comment">// 检测到调试器，退出程序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No debugger detected.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常程序逻辑</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program is running.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调试器进程名列表：在<strong> debuggerNames</strong> 数组中列出了常见的调试器进程名（如<strong> ollydbg.exe</strong>, <strong>x64dbg.exe</strong> 等）。可以根据需要添加更多的调试器进程名。<br>CreateToolhelp32Snapshot：这是一个 Windows API，用于创建系统中所有进程的快照，以便遍历这些进程。<br>Process32First 和 Process32Next：这些函数用于遍历进程快照中的每一个进程。<br>tolower 为了匹配时忽略大小写，将进程名全部转换为小写进行比较。<br>ExitProcess：如果发现调试器进程，程序直接退出。<p></p><p>代码在执行时遍历系统中所有正在运行的进程，并检查是否有已知的调试器进程在运行。如果发现某个调试器进程（如 ollydbg.exe），则程序会直接退出，否则会继续运行。这种方法可以用来检测外部调试器是否正在运行，但它不是百分之百可靠，因为高级调试器可能会通过修改进程名或隐藏自己来规避检测。</p><h2 id="5窗口名反调试"><a class="anchor" href="#5窗口名反调试">#</a> （5）窗口名反调试</h2><p>检测已打开窗口的窗口也是一种较为常用的反调试手段。示例代码如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义要检查的调试器窗口名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* debuggerWindowNames[] = &#123;</span><br><span class="line">    <span class="string">&quot;OllyDbg&quot;</span>,  <span class="string">&quot;x64dbg&quot;</span>, <span class="string">&quot;IDA&quot;</span>, <span class="string">&quot;WinDbg&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举系统中所有窗口，查找是否有调试器窗口存在</span></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWindowsProc</span><span class="params">(HWND hwnd, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> windowTitle[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">GetWindowTextA</span>(hwnd, windowTitle, <span class="built_in">sizeof</span>(windowTitle));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历已知的调试器窗口名称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; debuggerWindowName : debuggerWindowNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(windowTitle, debuggerWindowName)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Debugger window detected: &quot;</span> &lt;&lt; windowTitle &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> FALSE;  <span class="comment">// 找到调试器窗口，停止枚举</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// 继续枚举其他窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否存在调试器窗口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsDebuggerWindowOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">EnumWindows</span>(EnumWindowsProc, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsDebuggerWindowOpen</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Debugger window detected! Exiting...\n&quot;</span>;</span><br><span class="line">        <span class="built_in">ExitProcess</span>(<span class="number">1</span>);  <span class="comment">// 检测到调试器窗口，退出程序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No debugger window detected.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program is running.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>EnumWindows：这是 Windows API，允许遍历系统中所有的顶层窗口。每找到一个窗口，就会调用回调函数<strong> EnumWindowsProc</strong>。<br>EnumWindowsProc：这是枚举窗口的回调函数。通过<strong> GetWindowTextA</strong> 函数获取窗口标题，然后使用<strong> strstr</strong> 来判断窗口名是否包含已知调试器窗口名称。<br>ExitProcess：如果检测到调试器窗口，程序直接退出。<p></p><p>有些调试器允许用户自定义窗口名，因此该方法并非完全可靠。高级调试器同样可能会通过修改窗口名或隐藏窗口来规避检测。例如，OD 在刚启动时的窗口名为 “OllyDbg - [CPU]”，而加载程序后会有所改变，但前几个字节仍然为 “OllyDbg”，对于这类窗口，规定字符串的检测长度往往能取得不错的效果。</p><h2 id="6时间戳反调试"><a class="anchor" href="#6时间戳反调试">#</a> （6）时间戳反调试</h2><p>正常情况下，CPU 的执行速度是非常快的，每秒能执行数条指令，每条指令的执行时间非常短。而在调试状态下，由于软件中断、单步调试等因素，可能会造成指令间的执行间隔远大于正常时间，分别记录两条指令执行前后的时间戳，利用时间戳的差值便能够判断当前进程是否处于被调试状态。 时间戳反调试有三种常用手段：</p><pre><code>rdtsc: 汇编指令，能够以纳秒级记录系统启动以来的时间戳，返回值保存在EDX:EAX(高位保存到EDX，低位保存到EAX)中。
QueryPerformanceCounter:能够以微秒为单位高精度计时。  
GetTickCount:返回值为自系统启动以来所经过的毫秒数。  
</code></pre><p>例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DWORD time1 = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    <span class="type">int</span> result, a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    __asm(</span><br><span class="line">            <span class="string">&quot;movl %1, %%ebx\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;addl %%ebx, %0&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span> (result)</span><br><span class="line">            : <span class="string">&quot;r&quot;</span> (b), <span class="string">&quot;0&quot;</span> (a)</span><br><span class="line">            );</span><br><span class="line">    DWORD time2 = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    <span class="keyword">if</span>(time2-time1&gt;<span class="number">0x10</span>)</span><br><span class="line">        <span class="built_in">ExitProcess</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program started.\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序执行完内联汇编后，会计算前后时间差。如果时间差超过 16 毫秒（0x10），程序会调用<strong> ExitProcess</strong> 强制退出。这可以用于反调试：调试器往往会减缓程序的执行速度，因此通过这种时间检测方法可以检测到调试行为。<p></p><h2 id="7硬件断点检测反调试"><a class="anchor" href="#7硬件断点检测反调试">#</a> （7）硬件断点检测反调试</h2><p>硬件断点是调试器常用的手段之一，它通过 CPU 的调试寄存器（如<strong> DR0-DR7</strong>）设置断点。可以通过检查这些寄存器是否有断点设置来检测调试器。使用<strong> GetThreadContext</strong> API 来获取当前线程的上下文，检查调试寄存器（<strong>DR0</strong> 到<strong> DR3</strong>）是否设置断点。<br></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT ctx = &#123;&#125;<span class="comment">;</span></span><br><span class="line">ctx<span class="number">.</span>ContextFlags = CONTEXT_DEBUG_REGISTERS<span class="comment">;</span></span><br><span class="line">GetThreadContext(GetCurrentThread(), &amp;ctx)<span class="comment">;</span></span><br><span class="line">if (ctx<span class="number">.</span><span class="built_in">Dr0</span> || ctx<span class="number">.</span><span class="built_in">Dr1</span> || ctx<span class="number">.</span><span class="built_in">Dr2</span> || ctx<span class="number">.</span><span class="built_in">Dr3</span>) &#123;</span><br><span class="line">    ExitProcess(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="8异常处理反调试"><a class="anchor" href="#8异常处理反调试">#</a> （8）异常处理反调试</h2><p>调试器通常会捕获异常，反调试技术可以通过故意引发异常并检查其处理方式来检测调试器。通过引发<strong> INT 3</strong> 指令（断点中断）或其他异常（如除零异常），查看是否有异常处理程序被插入，然后使用<strong> SetUnhandledExceptionFilter</strong> 设置自定义的异常处理程序。<br></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">__try</span> &#123;</span><br><span class="line">    <span class="variable">__asm</span> &#123; int <span class="number">3</span> &#125;  <span class="comment">// 触发断点异常</span></span><br><span class="line">&#125; <span class="variable">__except</span> (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">    <span class="comment">// 如果捕获了异常，则说明没有调试器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;No debugger detected.&quot;</span> &lt;&lt; std::<span class="literal">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="9单步检测反调试"><a class="anchor" href="#9单步检测反调试">#</a> （9）单步检测反调试</h2><p>单步检测反调试是一种通过检测 CPU 的单步执行（Trap Flag, TF）来判断是否有调试器介入的技术。当调试器单步执行目标程序时，CPU 的<strong> TF</strong> 标志会被设置为 1，这会导致在每条指令执行完后触发一个调试中断。因此，程序可以通过监控<strong> TF</strong> 标志的变化来检测调试行为。</p><p>Trap Flag（TF）：当 EFLAGS 寄存器中的 TF 标志被置为 1 时，CPU 会进入单步模式，每执行一条指令后都会产生一个调试中断（INT 1）。通过检查和控制 TF 标志，可以判断程序是否被调试器单步执行。如果调试器处于单步调试模式，TF 标志会被置 1，程序可以利用这一特性检测调试行为。<br>例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存原来的EFLAGS寄存器值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> eflags;</span><br><span class="line"></span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushfd                   <span class="comment">// 将EFLAGS压入栈中</span></span><br><span class="line">        pop eax                  <span class="comment">// 将栈顶的EFLAGS值弹出到EAX寄存器</span></span><br><span class="line">        mov eflags, eax          <span class="comment">// 保存EFLAGS寄存器到eflags变量</span></span><br><span class="line">        <span class="keyword">or</span> eax, <span class="number">0x100</span>            <span class="comment">// 设置TF（Trap Flag）位为1，启用单步调试模式</span></span><br><span class="line">        push eax                 <span class="comment">// 将修改后的EFLAGS值压回栈</span></span><br><span class="line">        popfd                    <span class="comment">// 恢复EFLAGS寄存器，使Trap Flag生效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行单步调试后检测</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        nop                      <span class="comment">// 一个空操作，用于单步执行检测</span></span><br><span class="line">        pushfd                   <span class="comment">// 将当前的EFLAGS寄存器值压入栈</span></span><br><span class="line">        pop eax                  <span class="comment">// 弹出EFLAGS到EAX</span></span><br><span class="line">        mov eflags, eax          <span class="comment">// 保存当前的EFLAGS值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测Trap Flag是否被清除（如果有调试器在调试，该标志可能被复位）</span></span><br><span class="line">    <span class="keyword">if</span> (eflags &amp; <span class="number">0x100</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No debugger detected (TF still set).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Debugger detected (TF cleared).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">ExitProcess</span>(<span class="number">0</span>);           <span class="comment">// 检测到调试器，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果程序在执行 nop 指令后，TF 标志依然保持为 1，则说明程序未被调试，输出 “No debugger detected (TF still set)”。如果程序发现 TF 标志被清除（调试器可能重置了该标志），则输出 “Debugger detected (TF cleared)”，并终止程序执行。<p></p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%94%9F%E6%B4%BB%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 学习及生活笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-11-21 21:28:02" itemprop="dateModified" datetime="2025-11-21T21:28:02+08:00">2025-11-21</time> </span><span id="2025/11/21/逆向常见反调试合集/" class="item leancloud_visitors" data-flag-title="逆向常见反调试合集" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Pretend <i class="ic i-at"><em>@</em></i>Hexo</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2025/11/21/%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E5%8F%8D%E8%B0%83%E8%AF%95%E5%90%88%E9%9B%86/" title="逆向常见反调试合集">http://example.com/2025/11/21/逆向常见反调试合集/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/11/10/2025UofTCTFreverse%E5%A4%8D%E7%8E%B03/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;t.alcy.cc&#x2F;fj?686190" title="2025UofTCTFreverse复现3"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 复现</span><h3>2025UofTCTFreverse复现3</h3></a></div><div class="item right"><a href="/2025/11/22/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;t.alcy.cc&#x2F;fj?753878" title="RC4加密算法"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 分享</span><h3>RC4加密算法</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E5%8F%8D%E8%B0%83%E8%AF%95%E5%90%88%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">逆向常见反调试合集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%8D%E8%B0%83%E8%AF%95%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1、反调试简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E8%B0%83%E8%AF%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2、反调试的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1api%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">（1）API 反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2peb%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.4.</span> <span class="toc-text">（2）PEB 反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3tls%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.5.</span> <span class="toc-text">（3）TLS 反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E8%BF%9B%E7%A8%8B%E5%90%8D%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.6.</span> <span class="toc-text">（4）进程名反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E7%AA%97%E5%8F%A3%E5%90%8D%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.7.</span> <span class="toc-text">（5）窗口名反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%97%B6%E9%97%B4%E6%88%B3%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.8.</span> <span class="toc-text">（6）时间戳反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9%E6%A3%80%E6%B5%8B%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.9.</span> <span class="toc-text">（7）硬件断点检测反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.10.</span> <span class="toc-text">（8）异常处理反调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E5%8D%95%E6%AD%A5%E6%A3%80%E6%B5%8B%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">1.11.</span> <span class="toc-text">（9）单步检测反调试</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2025/11/01/%E5%90%AF%E8%88%AA%E4%B9%8B%E7%AB%A0/" rel="bookmark" title="启航之章">启航之章</a></li><li class="active"><a href="/2025/11/21/%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E5%8F%8D%E8%B0%83%E8%AF%95%E5%90%88%E9%9B%86/" rel="bookmark" title="逆向常见反调试合集">逆向常见反调试合集</a></li><li><a href="/2025/11/22/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" rel="bookmark" title="RC4加密算法">RC4加密算法</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Pretend" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Pretend</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">6</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">2</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2025/11/10/2025UofTCTFreverse%E5%A4%8D%E7%8E%B03/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2025/11/22/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E4%BA%AB/" title="分类于 分享">分享</a></div><span><a href="/2025/11/01/%E5%90%AF%E8%88%AA%E4%B9%8B%E7%AB%A0/" title="启航之章">启航之章</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%A4%8D%E7%8E%B0/" title="分类于 复现">复现</a></div><span><a href="/2025/11/10/2025UofTCTFreverse%E5%A4%8D%E7%8E%B03/" title="2025UofTCTFreverse复现3">2025UofTCTFreverse复现3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%A4%8D%E7%8E%B0/" title="分类于 复现">复现</a></div><span><a href="/2025/11/08/2025UofTCTFreverse%E5%A4%8D%E7%8E%B01/" title="2025UofTCTFreverse复现1">2025UofTCTFreverse复现1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E4%BA%AB/" title="分类于 分享">分享</a></div><span><a href="/2025/11/22/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="RC4加密算法">RC4加密算法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%A4%8D%E7%8E%B0/" title="分类于 复现">复现</a></div><span><a href="/2025/11/10/2025UofTCTFreverse%E5%A4%8D%E7%8E%B02/" title="2025UofTCTFreverse复现2">2025UofTCTFreverse复现2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E4%BA%AB/" title="分类于 分享">分享</a></div><span><a href="/2025/11/21/%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E5%8F%8D%E8%B0%83%E8%AF%95%E5%90%88%E9%9B%86/" title="逆向常见反调试合集">逆向常见反调试合集</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Pretend @ Yume Shoka</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/11/21/逆向常见反调试合集/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->